/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Check man REST API documentation
 * Official REST documentation
 *
 * OpenAPI spec version: 0.0.1
 * Contact: ondrej.chrbolka@upce.cz
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost:9001".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AppUserGlobalRoleDtoV1
 */
export interface AppUserGlobalRoleDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof AppUserGlobalRoleDtoV1
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AppUserGlobalRoleDtoV1
     */
    appUserId?: number;
    /**
     * 
     * @type {number}
     * @memberof AppUserGlobalRoleDtoV1
     */
    globalRoleId?: number;
    /**
     * 
     * @type {Links}
     * @memberof AppUserGlobalRoleDtoV1
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface AppUserResponseDtoV1
 */
export interface AppUserResponseDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof AppUserResponseDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AppUserResponseDtoV1
     */
    stagId: string;
    /**
     * 
     * @type {string}
     * @memberof AppUserResponseDtoV1
     */
    mail: string;
    /**
     * 
     * @type {string}
     * @memberof AppUserResponseDtoV1
     */
    displayName: string;
    /**
     * 
     * @type {Date}
     * @memberof AppUserResponseDtoV1
     */
    registrationDate: Date;
    /**
     * 
     * @type {Date}
     * @memberof AppUserResponseDtoV1
     */
    lastAccessDate: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AppUserResponseDtoV1
     */
    disabled: boolean;
    /**
     * 
     * @type {Array<GlobalRoleResponseDtoV1>}
     * @memberof AppUserResponseDtoV1
     */
    globalRoles: Array<GlobalRoleResponseDtoV1>;
    /**
     * 
     * @type {Array<CourseSemesterRolesResponseDtoV1>}
     * @memberof AppUserResponseDtoV1
     */
    courseRoles: Array<CourseSemesterRolesResponseDtoV1>;
    /**
     * 
     * @type {Links}
     * @memberof AppUserResponseDtoV1
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface AuthenticationResponseDtoV1
 */
export interface AuthenticationResponseDtoV1 {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponseDtoV1
     */
    token: string;
}
/**
 * 
 * @export
 * @interface ChallengeIdAttachmentBody
 */
export interface ChallengeIdAttachmentBody {
    /**
     * 
     * @type {Blob}
     * @memberof ChallengeIdAttachmentBody
     */
    file: Blob;
}
/**
 * 
 * @export
 * @interface ChallengeRequestDtoV1
 */
export interface ChallengeRequestDtoV1 {
    /**
     * 
     * @type {string}
     * @memberof ChallengeRequestDtoV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ChallengeRequestDtoV1
     */
    description: string;
    /**
     * 
     * @type {Date}
     * @memberof ChallengeRequestDtoV1
     */
    deadlineDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ChallengeRequestDtoV1
     */
    startDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ChallengeRequestDtoV1
     */
    challengeKind: ChallengeRequestDtoV1.ChallengeKindEnum;
}

/**
 * @export
 * @namespace ChallengeRequestDtoV1
 */
export namespace ChallengeRequestDtoV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum ChallengeKindEnum {
        OPTIONAL = <any> 'OPTIONAL',
        MANDATORY = <any> 'MANDATORY',
        CREDIT = <any> 'CREDIT',
        EXAM = <any> 'EXAM'
    }
}
/**
 * 
 * @export
 * @interface ChallengeResponseDtoV1
 */
export interface ChallengeResponseDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof ChallengeResponseDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponseDtoV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponseDtoV1
     */
    description: string;
    /**
     * 
     * @type {Date}
     * @memberof ChallengeResponseDtoV1
     */
    deadlineDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ChallengeResponseDtoV1
     */
    startDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ChallengeResponseDtoV1
     */
    challengeKind: ChallengeResponseDtoV1.ChallengeKindEnum;
    /**
     * 
     * @type {Array<FileAttachmentResponseDtoV1>}
     * @memberof ChallengeResponseDtoV1
     */
    fileAttachments: Array<FileAttachmentResponseDtoV1>;
    /**
     * 
     * @type {Links}
     * @memberof ChallengeResponseDtoV1
     */
    links?: Links;
}

/**
 * @export
 * @namespace ChallengeResponseDtoV1
 */
export namespace ChallengeResponseDtoV1 {
    /**
     * @export
     * @enum {string}
     */
    export enum ChallengeKindEnum {
        OPTIONAL = <any> 'OPTIONAL',
        MANDATORY = <any> 'MANDATORY',
        CREDIT = <any> 'CREDIT',
        EXAM = <any> 'EXAM'
    }
}
/**
 * 
 * @export
 * @interface CourseRequestDtoV1
 */
export interface CourseRequestDtoV1 {
    /**
     * 
     * @type {string}
     * @memberof CourseRequestDtoV1
     */
    stagId: string;
    /**
     * 
     * @type {string}
     * @memberof CourseRequestDtoV1
     */
    name: string;
    /**
     * 
     * @type {Date}
     * @memberof CourseRequestDtoV1
     */
    dateCreation: Date;
    /**
     * 
     * @type {string}
     * @memberof CourseRequestDtoV1
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseRequestDtoV1
     */
    template?: string;
    /**
     * 
     * @type {Array<CourseSemesterRequestDtoV1>}
     * @memberof CourseRequestDtoV1
     */
    semesters?: Array<CourseSemesterRequestDtoV1>;
}
/**
 * 
 * @export
 * @interface CourseResponseDtoV1
 */
export interface CourseResponseDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof CourseResponseDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDtoV1
     */
    stagId: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDtoV1
     */
    name: string;
    /**
     * 
     * @type {Date}
     * @memberof CourseResponseDtoV1
     */
    dateCreation: Date;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDtoV1
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof CourseResponseDtoV1
     */
    template?: string;
    /**
     * 
     * @type {Array<CourseSemesterResponseDtoV1>}
     * @memberof CourseResponseDtoV1
     */
    semesters: Array<CourseSemesterResponseDtoV1>;
    /**
     * 
     * @type {Links}
     * @memberof CourseResponseDtoV1
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface CourseSemesterRequestDtoV1
 */
export interface CourseSemesterRequestDtoV1 {
    /**
     * 
     * @type {string}
     * @memberof CourseSemesterRequestDtoV1
     */
    note?: string;
    /**
     * 
     * @type {Date}
     * @memberof CourseSemesterRequestDtoV1
     */
    dateStart: Date;
    /**
     * 
     * @type {Date}
     * @memberof CourseSemesterRequestDtoV1
     */
    dateEnd: Date;
}
/**
 * 
 * @export
 * @interface CourseSemesterResponseDtoV1
 */
export interface CourseSemesterResponseDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof CourseSemesterResponseDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CourseSemesterResponseDtoV1
     */
    note?: string;
    /**
     * 
     * @type {Date}
     * @memberof CourseSemesterResponseDtoV1
     */
    dateStart?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CourseSemesterResponseDtoV1
     */
    dateEnd?: Date;
    /**
     * 
     * @type {Links}
     * @memberof CourseSemesterResponseDtoV1
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface CourseSemesterRoleDtoV1
 */
export interface CourseSemesterRoleDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof CourseSemesterRoleDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CourseSemesterRoleDtoV1
     */
    name: string;
    /**
     * 
     * @type {Links}
     * @memberof CourseSemesterRoleDtoV1
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface CourseSemesterRolesResponseDtoV1
 */
export interface CourseSemesterRolesResponseDtoV1 {
    /**
     * 
     * @type {CourseSemesterResponseDtoV1}
     * @memberof CourseSemesterRolesResponseDtoV1
     */
    semester: CourseSemesterResponseDtoV1;
    /**
     * 
     * @type {Array<CourseSemesterRoleDtoV1>}
     * @memberof CourseSemesterRolesResponseDtoV1
     */
    roles: Array<CourseSemesterRoleDtoV1>;
}
/**
 * 
 * @export
 * @interface FileAttachmentResponseDtoV1
 */
export interface FileAttachmentResponseDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof FileAttachmentResponseDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FileAttachmentResponseDtoV1
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileAttachmentResponseDtoV1
     */
    available: boolean;
    /**
     * 
     * @type {Date}
     * @memberof FileAttachmentResponseDtoV1
     */
    creationDate: Date;
    /**
     * 
     * @type {Links}
     * @memberof FileAttachmentResponseDtoV1
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface GlobalRoleResponseDtoV1
 */
export interface GlobalRoleResponseDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof GlobalRoleResponseDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GlobalRoleResponseDtoV1
     */
    name: string;
    /**
     * 
     * @type {Links}
     * @memberof GlobalRoleResponseDtoV1
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    hreflang?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    deprecation?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    templated?: boolean;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    [key: string]: Link;

}
/**
 * 
 * @export
 * @interface MicrosoftOAuthResponseDtoV1
 */
export interface MicrosoftOAuthResponseDtoV1 {
    /**
     * 
     * @type {string}
     * @memberof MicrosoftOAuthResponseDtoV1
     */
    redirectURI: string;
}
/**
 * 
 * @export
 * @interface PermitAppUserChallengeRequestDtoV1
 */
export interface PermitAppUserChallengeRequestDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof PermitAppUserChallengeRequestDtoV1
     */
    appUserId: number;
    /**
     * 
     * @type {Date}
     * @memberof PermitAppUserChallengeRequestDtoV1
     */
    accessTo: Date;
}
/**
 * 
 * @export
 * @interface RemoveAccessAppUserChallengeRequestDtoV1
 */
export interface RemoveAccessAppUserChallengeRequestDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof RemoveAccessAppUserChallengeRequestDtoV1
     */
    appUserId: number;
}
/**
 * 
 * @export
 * @interface RequirementRequestDtoV1
 */
export interface RequirementRequestDtoV1 {
    /**
     * 
     * @type {string}
     * @memberof RequirementRequestDtoV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RequirementRequestDtoV1
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof RequirementRequestDtoV1
     */
    minPoint: number;
    /**
     * 
     * @type {number}
     * @memberof RequirementRequestDtoV1
     */
    maxPoint: number;
}
/**
 * 
 * @export
 * @interface RequirementResponseDtoV1
 */
export interface RequirementResponseDtoV1 {
    /**
     * 
     * @type {number}
     * @memberof RequirementResponseDtoV1
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RequirementResponseDtoV1
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RequirementResponseDtoV1
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof RequirementResponseDtoV1
     */
    minPoint: number;
    /**
     * 
     * @type {number}
     * @memberof RequirementResponseDtoV1
     */
    maxPoint: number;
    /**
     * 
     * @type {Links}
     * @memberof RequirementResponseDtoV1
     */
    links?: Links;
}
/**
 * AppUserV1Api - fetch parameter creator
 * @export
 */
export const AppUserV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block app user. Remove access to every endpoint, not change related permissions.
         * @param {string} stagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable(stagId: string, options: any = {}): FetchArgs {
            // verify required parameter 'stagId' is not null or undefined
            if (stagId === null || stagId === undefined) {
                throw new RequiredError('stagId','Required parameter stagId was null or undefined when calling disable.');
            }
            const localVarPath = `/v1/app-user/{stagId}/block`
                .replace(`{${"stagId"}}`, encodeURIComponent(String(stagId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unblock disabled app user. Provide access to every endpoint related to his permissions.
         * @param {string} stagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enable(stagId: string, options: any = {}): FetchArgs {
            // verify required parameter 'stagId' is not null or undefined
            if (stagId === null || stagId === undefined) {
                throw new RequiredError('stagId','Required parameter stagId was null or undefined when calling enable.');
            }
            const localVarPath = `/v1/app-user/{stagId}/unblock`
                .replace(`{${"stagId"}}`, encodeURIComponent(String(stagId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppUserV1Api - functional programming interface
 * @export
 */
export const AppUserV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Block app user. Remove access to every endpoint, not change related permissions.
         * @param {string} stagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable(stagId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppUserV1ApiFetchParamCreator(configuration).disable(stagId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unblock disabled app user. Provide access to every endpoint related to his permissions.
         * @param {string} stagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enable(stagId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppUserV1ApiFetchParamCreator(configuration).enable(stagId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppUserV1Api - factory interface
 * @export
 */
export const AppUserV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Block app user. Remove access to every endpoint, not change related permissions.
         * @param {string} stagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disable(stagId: string, options?: any) {
            return AppUserV1ApiFp(configuration).disable(stagId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unblock disabled app user. Provide access to every endpoint related to his permissions.
         * @param {string} stagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enable(stagId: string, options?: any) {
            return AppUserV1ApiFp(configuration).enable(stagId, options)(fetch, basePath);
        },
    };
};

/**
 * AppUserV1Api - object-oriented interface
 * @export
 * @class AppUserV1Api
 * @extends {BaseAPI}
 */
export class AppUserV1Api extends BaseAPI {
    /**
     * 
     * @summary Block app user. Remove access to every endpoint, not change related permissions.
     * @param {string} stagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppUserV1Api
     */
    public disable(stagId: string, options?: any) {
        return AppUserV1ApiFp(this.configuration).disable(stagId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unblock disabled app user. Provide access to every endpoint related to his permissions.
     * @param {string} stagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppUserV1Api
     */
    public enable(stagId: string, options?: any) {
        return AppUserV1ApiFp(this.configuration).enable(stagId, options)(this.fetch, this.basePath);
    }

}
/**
 * ChallengeV1Api - fetch parameter creator
 * @export
 */
export const ChallengeV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(courseId: number, semesterId: number, challengeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling _delete.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling _delete.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling _delete.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new challenge.
         * @param {ChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add1(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling add1.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling add1.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling add1.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChallengeRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download file linked with challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling download.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling download.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling download.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling download.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/attachment/{attachmentId}/download`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing challenge based on id.
         * @param {ChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling edit.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling edit.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling edit.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling edit.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChallengeRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find challenge based on challenge id.
         * @param {number} id 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1(id: number, courseId: number, semesterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling find1.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling find1.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling find1.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find file attachment based on file attachment id.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFileAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling findFileAttachment.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling findFileAttachment.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling findFileAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling findFileAttachment.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/attachment/{attachmentId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Permit student (app user) to access challenge
         * @param {PermitAppUserChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitAccessAppUser(body: PermitAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling permitAccessAppUser.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling permitAccessAppUser.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling permitAccessAppUser.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling permitAccessAppUser.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/app-user/permit`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PermitAppUserChallengeRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dissable student (app user) to access challenge
         * @param {RemoveAccessAppUserChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccessAppUser(body: RemoveAccessAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling removeAccessAppUser.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling removeAccessAppUser.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling removeAccessAppUser.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling removeAccessAppUser.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/app-user/disable`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RemoveAccessAppUserChallengeRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete file attachment.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling removeAttachment.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling removeAttachment.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling removeAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling removeAttachment.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/attachment/{attachmentId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find challenge and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(courseId: number, semesterId: number, search?: string, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling search1.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling search1.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find file attachments based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(courseId: number, semesterId: number, challengeId: number, search?: string, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling search3.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling search3.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling search3.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/attachment`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload new file to challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {ChallengeIdAttachmentBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(courseId: number, semesterId: number, challengeId: number, body?: ChallengeIdAttachmentBody, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling upload.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling upload.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling upload.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/attachment`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChallengeIdAttachmentBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChallengeV1Api - functional programming interface
 * @export
 */
export const ChallengeV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(courseId: number, semesterId: number, challengeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration)._delete(courseId, semesterId, challengeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new challenge.
         * @param {ChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add1(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeResponseDtoV1> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).add1(body, courseId, semesterId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Download file linked with challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).download(courseId, semesterId, challengeId, attachmentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update existing challenge based on id.
         * @param {ChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeResponseDtoV1> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).edit(body, courseId, semesterId, challengeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find challenge based on challenge id.
         * @param {number} id 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1(id: number, courseId: number, semesterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeResponseDtoV1> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).find1(id, courseId, semesterId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find file attachment based on file attachment id.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFileAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseResponseDtoV1> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).findFileAttachment(courseId, semesterId, challengeId, attachmentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Permit student (app user) to access challenge
         * @param {PermitAppUserChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitAccessAppUser(body: PermitAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).permitAccessAppUser(body, courseId, semesterId, challengeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Dissable student (app user) to access challenge
         * @param {RemoveAccessAppUserChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccessAppUser(body: RemoveAccessAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).removeAccessAppUser(body, courseId, semesterId, challengeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete file attachment.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).removeAttachment(courseId, semesterId, challengeId, attachmentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find challenge and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(courseId: number, semesterId: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ChallengeResponseDtoV1>> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).search1(courseId, semesterId, search, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find file attachments based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(courseId: number, semesterId: number, challengeId: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FileAttachmentResponseDtoV1>> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).search3(courseId, semesterId, challengeId, search, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Upload new file to challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {ChallengeIdAttachmentBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(courseId: number, semesterId: number, challengeId: number, body?: ChallengeIdAttachmentBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileAttachmentResponseDtoV1> {
            const localVarFetchArgs = ChallengeV1ApiFetchParamCreator(configuration).upload(courseId, semesterId, challengeId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChallengeV1Api - factory interface
 * @export
 */
export const ChallengeV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(courseId: number, semesterId: number, challengeId: number, options?: any) {
            return ChallengeV1ApiFp(configuration)._delete(courseId, semesterId, challengeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new challenge.
         * @param {ChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add1(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).add1(body, courseId, semesterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Download file linked with challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).download(courseId, semesterId, challengeId, attachmentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update existing challenge based on id.
         * @param {ChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).edit(body, courseId, semesterId, challengeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find challenge based on challenge id.
         * @param {number} id 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1(id: number, courseId: number, semesterId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).find1(id, courseId, semesterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find file attachment based on file attachment id.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFileAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).findFileAttachment(courseId, semesterId, challengeId, attachmentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Permit student (app user) to access challenge
         * @param {PermitAppUserChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        permitAccessAppUser(body: PermitAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).permitAccessAppUser(body, courseId, semesterId, challengeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Dissable student (app user) to access challenge
         * @param {RemoveAccessAppUserChallengeRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAccessAppUser(body: RemoveAccessAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).removeAccessAppUser(body, courseId, semesterId, challengeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete file attachment.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} attachmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any) {
            return ChallengeV1ApiFp(configuration).removeAttachment(courseId, semesterId, challengeId, attachmentId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find challenge and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(courseId: number, semesterId: number, search?: string, options?: any) {
            return ChallengeV1ApiFp(configuration).search1(courseId, semesterId, search, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find file attachments based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search3(courseId: number, semesterId: number, challengeId: number, search?: string, options?: any) {
            return ChallengeV1ApiFp(configuration).search3(courseId, semesterId, challengeId, search, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Upload new file to challenge.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {ChallengeIdAttachmentBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(courseId: number, semesterId: number, challengeId: number, body?: ChallengeIdAttachmentBody, options?: any) {
            return ChallengeV1ApiFp(configuration).upload(courseId, semesterId, challengeId, body, options)(fetch, basePath);
        },
    };
};

/**
 * ChallengeV1Api - object-oriented interface
 * @export
 * @class ChallengeV1Api
 * @extends {BaseAPI}
 */
export class ChallengeV1Api extends BaseAPI {
    /**
     * 
     * @summary Delete challenge.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public _delete(courseId: number, semesterId: number, challengeId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration)._delete(courseId, semesterId, challengeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new challenge.
     * @param {ChallengeRequestDtoV1} body 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public add1(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).add1(body, courseId, semesterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Download file linked with challenge.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {number} attachmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public download(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).download(courseId, semesterId, challengeId, attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update existing challenge based on id.
     * @param {ChallengeRequestDtoV1} body 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public edit(body: ChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).edit(body, courseId, semesterId, challengeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find challenge based on challenge id.
     * @param {number} id 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public find1(id: number, courseId: number, semesterId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).find1(id, courseId, semesterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find file attachment based on file attachment id.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {number} attachmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public findFileAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).findFileAttachment(courseId, semesterId, challengeId, attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Permit student (app user) to access challenge
     * @param {PermitAppUserChallengeRequestDtoV1} body 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public permitAccessAppUser(body: PermitAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).permitAccessAppUser(body, courseId, semesterId, challengeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Dissable student (app user) to access challenge
     * @param {RemoveAccessAppUserChallengeRequestDtoV1} body 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public removeAccessAppUser(body: RemoveAccessAppUserChallengeRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).removeAccessAppUser(body, courseId, semesterId, challengeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete file attachment.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {number} attachmentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public removeAttachment(courseId: number, semesterId: number, challengeId: number, attachmentId: number, options?: any) {
        return ChallengeV1ApiFp(this.configuration).removeAttachment(courseId, semesterId, challengeId, attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find challenge and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public search1(courseId: number, semesterId: number, search?: string, options?: any) {
        return ChallengeV1ApiFp(this.configuration).search1(courseId, semesterId, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find file attachments based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public search3(courseId: number, semesterId: number, challengeId: number, search?: string, options?: any) {
        return ChallengeV1ApiFp(this.configuration).search3(courseId, semesterId, challengeId, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Upload new file to challenge.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {ChallengeIdAttachmentBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeV1Api
     */
    public upload(courseId: number, semesterId: number, challengeId: number, body?: ChallengeIdAttachmentBody, options?: any) {
        return ChallengeV1ApiFp(this.configuration).upload(courseId, semesterId, challengeId, body, options)(this.fetch, this.basePath);
    }

}
/**
 * CourseV1Api - fetch parameter creator
 * @export
 */
export const CourseV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new course (semesters could be included).
         * @param {CourseRequestDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(body: CourseRequestDtoV1, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling add.');
            }
            const localVarPath = `/v1/course`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CourseRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new semester.
         * @param {CourseSemesterRequestDtoV1} body 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSemester(body: CourseSemesterRequestDtoV1, courseId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addSemester.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling addSemester.');
            }
            const localVarPath = `/v1/course/{courseId}/semester`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CourseSemesterRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find course and semesters based on course id.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling find.');
            }
            const localVarPath = `/v1/course/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new course (semesters could be included)
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSemester(courseId: number, semesterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling findSemester.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling findSemester.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provide all roles to course based on logged user.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meRoles(courseId: number, semesterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling meRoles.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling meRoles.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/me`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete course.
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove1(courseId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling remove1.');
            }
            const localVarPath = `/v1/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete course semester.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSemester(courseId: number, semesterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling removeSemester.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling removeSemester.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find courses based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(search?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/course`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find course and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSemesters(courseId: number, search?: string, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling searchSemesters.');
            }
            const localVarPath = `/v1/course/{courseId}/semester`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing course based on id.
         * @param {CourseRequestDtoV1} body 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(body: CourseRequestDtoV1, courseId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling update.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling update.');
            }
            const localVarPath = `/v1/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CourseRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing course semester based on id.
         * @param {CourseSemesterRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSemester(body: CourseSemesterRequestDtoV1, courseId: number, semesterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSemester.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling updateSemester.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling updateSemester.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CourseSemesterRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseV1Api - functional programming interface
 * @export
 */
export const CourseV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new course (semesters could be included).
         * @param {CourseRequestDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(body: CourseRequestDtoV1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseResponseDtoV1> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).add(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new semester.
         * @param {CourseSemesterRequestDtoV1} body 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSemester(body: CourseSemesterRequestDtoV1, courseId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseSemesterResponseDtoV1> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).addSemester(body, courseId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find course and semesters based on course id.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseResponseDtoV1> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).find(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create new course (semesters could be included)
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSemester(courseId: number, semesterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseSemesterResponseDtoV1> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).findSemester(courseId, semesterId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Provide all roles to course based on logged user.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meRoles(courseId: number, semesterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CourseSemesterRoleDtoV1>> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).meRoles(courseId, semesterId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete course.
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove1(courseId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).remove1(courseId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete course semester.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSemester(courseId: number, semesterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).removeSemester(courseId, semesterId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find courses based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CourseResponseDtoV1>> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).search(search, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find course and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSemesters(courseId: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CourseSemesterResponseDtoV1>> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).searchSemesters(courseId, search, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update existing course based on id.
         * @param {CourseRequestDtoV1} body 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(body: CourseRequestDtoV1, courseId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseResponseDtoV1> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).update(body, courseId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update existing course semester based on id.
         * @param {CourseSemesterRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSemester(body: CourseSemesterRequestDtoV1, courseId: number, semesterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseSemesterResponseDtoV1> {
            const localVarFetchArgs = CourseV1ApiFetchParamCreator(configuration).updateSemester(body, courseId, semesterId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CourseV1Api - factory interface
 * @export
 */
export const CourseV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new course (semesters could be included).
         * @param {CourseRequestDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(body: CourseRequestDtoV1, options?: any) {
            return CourseV1ApiFp(configuration).add(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new semester.
         * @param {CourseSemesterRequestDtoV1} body 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSemester(body: CourseSemesterRequestDtoV1, courseId: number, options?: any) {
            return CourseV1ApiFp(configuration).addSemester(body, courseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find course and semesters based on course id.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(id: number, options?: any) {
            return CourseV1ApiFp(configuration).find(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create new course (semesters could be included)
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSemester(courseId: number, semesterId: number, options?: any) {
            return CourseV1ApiFp(configuration).findSemester(courseId, semesterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Provide all roles to course based on logged user.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meRoles(courseId: number, semesterId: number, options?: any) {
            return CourseV1ApiFp(configuration).meRoles(courseId, semesterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete course.
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove1(courseId: number, options?: any) {
            return CourseV1ApiFp(configuration).remove1(courseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete course semester.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSemester(courseId: number, semesterId: number, options?: any) {
            return CourseV1ApiFp(configuration).removeSemester(courseId, semesterId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find courses based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(search?: string, options?: any) {
            return CourseV1ApiFp(configuration).search(search, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find course and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSemesters(courseId: number, search?: string, options?: any) {
            return CourseV1ApiFp(configuration).searchSemesters(courseId, search, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update existing course based on id.
         * @param {CourseRequestDtoV1} body 
         * @param {number} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(body: CourseRequestDtoV1, courseId: number, options?: any) {
            return CourseV1ApiFp(configuration).update(body, courseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update existing course semester based on id.
         * @param {CourseSemesterRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSemester(body: CourseSemesterRequestDtoV1, courseId: number, semesterId: number, options?: any) {
            return CourseV1ApiFp(configuration).updateSemester(body, courseId, semesterId, options)(fetch, basePath);
        },
    };
};

/**
 * CourseV1Api - object-oriented interface
 * @export
 * @class CourseV1Api
 * @extends {BaseAPI}
 */
export class CourseV1Api extends BaseAPI {
    /**
     * 
     * @summary Create new course (semesters could be included).
     * @param {CourseRequestDtoV1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public add(body: CourseRequestDtoV1, options?: any) {
        return CourseV1ApiFp(this.configuration).add(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new semester.
     * @param {CourseSemesterRequestDtoV1} body 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public addSemester(body: CourseSemesterRequestDtoV1, courseId: number, options?: any) {
        return CourseV1ApiFp(this.configuration).addSemester(body, courseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find course and semesters based on course id.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public find(id: number, options?: any) {
        return CourseV1ApiFp(this.configuration).find(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create new course (semesters could be included)
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public findSemester(courseId: number, semesterId: number, options?: any) {
        return CourseV1ApiFp(this.configuration).findSemester(courseId, semesterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Provide all roles to course based on logged user.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public meRoles(courseId: number, semesterId: number, options?: any) {
        return CourseV1ApiFp(this.configuration).meRoles(courseId, semesterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete course.
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public remove1(courseId: number, options?: any) {
        return CourseV1ApiFp(this.configuration).remove1(courseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete course semester.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public removeSemester(courseId: number, semesterId: number, options?: any) {
        return CourseV1ApiFp(this.configuration).removeSemester(courseId, semesterId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find courses based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public search(search?: string, options?: any) {
        return CourseV1ApiFp(this.configuration).search(search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find course and semesters based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
     * @param {number} courseId 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public searchSemesters(courseId: number, search?: string, options?: any) {
        return CourseV1ApiFp(this.configuration).searchSemesters(courseId, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update existing course based on id.
     * @param {CourseRequestDtoV1} body 
     * @param {number} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public update(body: CourseRequestDtoV1, courseId: number, options?: any) {
        return CourseV1ApiFp(this.configuration).update(body, courseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update existing course semester based on id.
     * @param {CourseSemesterRequestDtoV1} body 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseV1Api
     */
    public updateSemester(body: CourseSemesterRequestDtoV1, courseId: number, semesterId: number, options?: any) {
        return CourseV1ApiFp(this.configuration).updateSemester(body, courseId, semesterId, options)(this.fetch, this.basePath);
    }

}
/**
 * GlobalRolesV1Api - fetch parameter creator
 * @export
 */
export const GlobalRolesV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign new role to user
         * @param {AppUserGlobalRoleDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign(body: AppUserGlobalRoleDtoV1, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling assign.');
            }
            const localVarPath = `/v1/global-role/app-user/assign`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AppUserGlobalRoleDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove role to user
         * @param {AppUserGlobalRoleDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(body: AppUserGlobalRoleDtoV1, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling remove.');
            }
            const localVarPath = `/v1/global-role/app-user/remove`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AppUserGlobalRoleDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalRolesV1Api - functional programming interface
 * @export
 */
export const GlobalRolesV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign new role to user
         * @param {AppUserGlobalRoleDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign(body: AppUserGlobalRoleDtoV1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GlobalRolesV1ApiFetchParamCreator(configuration).assign(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove role to user
         * @param {AppUserGlobalRoleDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(body: AppUserGlobalRoleDtoV1, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GlobalRolesV1ApiFetchParamCreator(configuration).remove(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GlobalRolesV1Api - factory interface
 * @export
 */
export const GlobalRolesV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Assign new role to user
         * @param {AppUserGlobalRoleDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign(body: AppUserGlobalRoleDtoV1, options?: any) {
            return GlobalRolesV1ApiFp(configuration).assign(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove role to user
         * @param {AppUserGlobalRoleDtoV1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(body: AppUserGlobalRoleDtoV1, options?: any) {
            return GlobalRolesV1ApiFp(configuration).remove(body, options)(fetch, basePath);
        },
    };
};

/**
 * GlobalRolesV1Api - object-oriented interface
 * @export
 * @class GlobalRolesV1Api
 * @extends {BaseAPI}
 */
export class GlobalRolesV1Api extends BaseAPI {
    /**
     * 
     * @summary Assign new role to user
     * @param {AppUserGlobalRoleDtoV1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRolesV1Api
     */
    public assign(body: AppUserGlobalRoleDtoV1, options?: any) {
        return GlobalRolesV1ApiFp(this.configuration).assign(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove role to user
     * @param {AppUserGlobalRoleDtoV1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalRolesV1Api
     */
    public remove(body: AppUserGlobalRoleDtoV1, options?: any) {
        return GlobalRolesV1ApiFp(this.configuration).remove(body, options)(this.fetch, this.basePath);
    }

}
/**
 * MeV1Api - fetch parameter creator
 * @export
 */
export const MeV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provide all available courses and semesters which can be register by logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableCourses(options: any = {}): FetchArgs {
            const localVarPath = `/v1/me/courses/available`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provide all courses and semesters related to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courses(options: any = {}): FetchArgs {
            const localVarPath = `/v1/me/courses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Information about current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(options: any = {}): FetchArgs {
            const localVarPath = `/v1/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeV1Api - functional programming interface
 * @export
 */
export const MeV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provide all available courses and semesters which can be register by logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableCourses(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CourseSemesterResponseDtoV1>> {
            const localVarFetchArgs = MeV1ApiFetchParamCreator(configuration).availableCourses(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Provide all courses and semesters related to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courses(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CourseSemesterResponseDtoV1>> {
            const localVarFetchArgs = MeV1ApiFetchParamCreator(configuration).courses(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Information about current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppUserResponseDtoV1> {
            const localVarFetchArgs = MeV1ApiFetchParamCreator(configuration).me(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MeV1Api - factory interface
 * @export
 */
export const MeV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Provide all available courses and semesters which can be register by logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableCourses(options?: any) {
            return MeV1ApiFp(configuration).availableCourses(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Provide all courses and semesters related to logged user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courses(options?: any) {
            return MeV1ApiFp(configuration).courses(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Information about current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(options?: any) {
            return MeV1ApiFp(configuration).me(options)(fetch, basePath);
        },
    };
};

/**
 * MeV1Api - object-oriented interface
 * @export
 * @class MeV1Api
 * @extends {BaseAPI}
 */
export class MeV1Api extends BaseAPI {
    /**
     * 
     * @summary Provide all available courses and semesters which can be register by logged user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeV1Api
     */
    public availableCourses(options?: any) {
        return MeV1ApiFp(this.configuration).availableCourses(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Provide all courses and semesters related to logged user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeV1Api
     */
    public courses(options?: any) {
        return MeV1ApiFp(this.configuration).courses(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Information about current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeV1Api
     */
    public me(options?: any) {
        return MeV1ApiFp(this.configuration).me(options)(this.fetch, this.basePath);
    }

}
/**
 * MicrosoftAuthenticationV1Api - fetch parameter creator
 * @export
 */
export const MicrosoftAuthenticationV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finish user authentication using Microsoft services.
         * @param {string} code 
         * @param {string} [redirectURI] 
         * @param {string} [state] 
         * @param {string} [adminConsent] 
         * @param {string} [error] 
         * @param {string} [errorDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finish(code: string, redirectURI?: string, state?: string, adminConsent?: string, error?: string, errorDescription?: string, options: any = {}): FetchArgs {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling finish.');
            }
            const localVarPath = `/v1/authentication/microsoft/finish`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectURI !== undefined) {
                localVarQueryParameter['redirectURI'] = redirectURI;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (adminConsent !== undefined) {
                localVarQueryParameter['adminConsent'] = adminConsent;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }

            if (errorDescription !== undefined) {
                localVarQueryParameter['errorDescription'] = errorDescription;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start user authentication using Microsoft services.
         * @param {string} [redirectURI] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(redirectURI?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/authentication/microsoft/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectURI !== undefined) {
                localVarQueryParameter['redirectURI'] = redirectURI;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MicrosoftAuthenticationV1Api - functional programming interface
 * @export
 */
export const MicrosoftAuthenticationV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Finish user authentication using Microsoft services.
         * @param {string} code 
         * @param {string} [redirectURI] 
         * @param {string} [state] 
         * @param {string} [adminConsent] 
         * @param {string} [error] 
         * @param {string} [errorDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finish(code: string, redirectURI?: string, state?: string, adminConsent?: string, error?: string, errorDescription?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthenticationResponseDtoV1> {
            const localVarFetchArgs = MicrosoftAuthenticationV1ApiFetchParamCreator(configuration).finish(code, redirectURI, state, adminConsent, error, errorDescription, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Start user authentication using Microsoft services.
         * @param {string} [redirectURI] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(redirectURI?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MicrosoftOAuthResponseDtoV1> {
            const localVarFetchArgs = MicrosoftAuthenticationV1ApiFetchParamCreator(configuration).start(redirectURI, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MicrosoftAuthenticationV1Api - factory interface
 * @export
 */
export const MicrosoftAuthenticationV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Finish user authentication using Microsoft services.
         * @param {string} code 
         * @param {string} [redirectURI] 
         * @param {string} [state] 
         * @param {string} [adminConsent] 
         * @param {string} [error] 
         * @param {string} [errorDescription] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finish(code: string, redirectURI?: string, state?: string, adminConsent?: string, error?: string, errorDescription?: string, options?: any) {
            return MicrosoftAuthenticationV1ApiFp(configuration).finish(code, redirectURI, state, adminConsent, error, errorDescription, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Start user authentication using Microsoft services.
         * @param {string} [redirectURI] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(redirectURI?: string, options?: any) {
            return MicrosoftAuthenticationV1ApiFp(configuration).start(redirectURI, options)(fetch, basePath);
        },
    };
};

/**
 * MicrosoftAuthenticationV1Api - object-oriented interface
 * @export
 * @class MicrosoftAuthenticationV1Api
 * @extends {BaseAPI}
 */
export class MicrosoftAuthenticationV1Api extends BaseAPI {
    /**
     * 
     * @summary Finish user authentication using Microsoft services.
     * @param {string} code 
     * @param {string} [redirectURI] 
     * @param {string} [state] 
     * @param {string} [adminConsent] 
     * @param {string} [error] 
     * @param {string} [errorDescription] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthenticationV1Api
     */
    public finish(code: string, redirectURI?: string, state?: string, adminConsent?: string, error?: string, errorDescription?: string, options?: any) {
        return MicrosoftAuthenticationV1ApiFp(this.configuration).finish(code, redirectURI, state, adminConsent, error, errorDescription, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Start user authentication using Microsoft services.
     * @param {string} [redirectURI] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthenticationV1Api
     */
    public start(redirectURI?: string, options?: any) {
        return MicrosoftAuthenticationV1ApiFp(this.configuration).start(redirectURI, options)(this.fetch, this.basePath);
    }

}
/**
 * RequirementV1Api - fetch parameter creator
 * @export
 */
export const RequirementV1ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new course (semesters could be included).
         * @param {RequirementRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add2(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling add2.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling add2.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling add2.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling add2.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/requirement`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequirementRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find requirement based on requirement id.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling find2.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling find2.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling find2.');
            }
            // verify required parameter 'requirementId' is not null or undefined
            if (requirementId === null || requirementId === undefined) {
                throw new RequiredError('requirementId','Required parameter requirementId was null or undefined when calling find2.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/requirement/{requirementId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)))
                .replace(`{${"requirementId"}}`, encodeURIComponent(String(requirementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete requirement.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling remove2.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling remove2.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling remove2.');
            }
            // verify required parameter 'requirementId' is not null or undefined
            if (requirementId === null || requirementId === undefined) {
                throw new RequiredError('requirementId','Required parameter requirementId was null or undefined when calling remove2.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/requirement/{requirementId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)))
                .replace(`{${"requirementId"}}`, encodeURIComponent(String(requirementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find requirements based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(courseId: number, semesterId: number, challengeId: number, search?: string, options: any = {}): FetchArgs {
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling search2.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling search2.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling search2.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/requirement`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing requirement based on id.
         * @param {RequirementRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, requirementId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling update1.');
            }
            // verify required parameter 'courseId' is not null or undefined
            if (courseId === null || courseId === undefined) {
                throw new RequiredError('courseId','Required parameter courseId was null or undefined when calling update1.');
            }
            // verify required parameter 'semesterId' is not null or undefined
            if (semesterId === null || semesterId === undefined) {
                throw new RequiredError('semesterId','Required parameter semesterId was null or undefined when calling update1.');
            }
            // verify required parameter 'challengeId' is not null or undefined
            if (challengeId === null || challengeId === undefined) {
                throw new RequiredError('challengeId','Required parameter challengeId was null or undefined when calling update1.');
            }
            // verify required parameter 'requirementId' is not null or undefined
            if (requirementId === null || requirementId === undefined) {
                throw new RequiredError('requirementId','Required parameter requirementId was null or undefined when calling update1.');
            }
            const localVarPath = `/v1/course/{courseId}/semester/{semesterId}/challenge/{challengeId}/requirement/{requirementId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"semesterId"}}`, encodeURIComponent(String(semesterId)))
                .replace(`{${"challengeId"}}`, encodeURIComponent(String(challengeId)))
                .replace(`{${"requirementId"}}`, encodeURIComponent(String(requirementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequirementRequestDtoV1" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RequirementV1Api - functional programming interface
 * @export
 */
export const RequirementV1ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new course (semesters could be included).
         * @param {RequirementRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add2(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CourseResponseDtoV1> {
            const localVarFetchArgs = RequirementV1ApiFetchParamCreator(configuration).add2(body, courseId, semesterId, challengeId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find requirement based on requirement id.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RequirementResponseDtoV1> {
            const localVarFetchArgs = RequirementV1ApiFetchParamCreator(configuration).find2(courseId, semesterId, challengeId, requirementId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete requirement.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RequirementV1ApiFetchParamCreator(configuration).remove2(courseId, semesterId, challengeId, requirementId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Find requirements based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(courseId: number, semesterId: number, challengeId: number, search?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RequirementResponseDtoV1>> {
            const localVarFetchArgs = RequirementV1ApiFetchParamCreator(configuration).search2(courseId, semesterId, challengeId, search, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update existing requirement based on id.
         * @param {RequirementRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RequirementResponseDtoV1> {
            const localVarFetchArgs = RequirementV1ApiFetchParamCreator(configuration).update1(body, courseId, semesterId, challengeId, requirementId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RequirementV1Api - factory interface
 * @export
 */
export const RequirementV1ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create new course (semesters could be included).
         * @param {RequirementRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add2(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
            return RequirementV1ApiFp(configuration).add2(body, courseId, semesterId, challengeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find requirement based on requirement id.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any) {
            return RequirementV1ApiFp(configuration).find2(courseId, semesterId, challengeId, requirementId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete requirement.
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any) {
            return RequirementV1ApiFp(configuration).remove2(courseId, semesterId, challengeId, requirementId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find requirements based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search2(courseId: number, semesterId: number, challengeId: number, search?: string, options?: any) {
            return RequirementV1ApiFp(configuration).search2(courseId, semesterId, challengeId, search, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update existing requirement based on id.
         * @param {RequirementRequestDtoV1} body 
         * @param {number} courseId 
         * @param {number} semesterId 
         * @param {number} challengeId 
         * @param {number} requirementId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any) {
            return RequirementV1ApiFp(configuration).update1(body, courseId, semesterId, challengeId, requirementId, options)(fetch, basePath);
        },
    };
};

/**
 * RequirementV1Api - object-oriented interface
 * @export
 * @class RequirementV1Api
 * @extends {BaseAPI}
 */
export class RequirementV1Api extends BaseAPI {
    /**
     * 
     * @summary Create new course (semesters could be included).
     * @param {RequirementRequestDtoV1} body 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequirementV1Api
     */
    public add2(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, options?: any) {
        return RequirementV1ApiFp(this.configuration).add2(body, courseId, semesterId, challengeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find requirement based on requirement id.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {number} requirementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequirementV1Api
     */
    public find2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any) {
        return RequirementV1ApiFp(this.configuration).find2(courseId, semesterId, challengeId, requirementId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete requirement.
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {number} requirementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequirementV1Api
     */
    public remove2(courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any) {
        return RequirementV1ApiFp(this.configuration).remove2(courseId, semesterId, challengeId, requirementId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Find requirements based on search criteria. For supported operators please visit: https://github.com/jirutka/rsql-parser
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequirementV1Api
     */
    public search2(courseId: number, semesterId: number, challengeId: number, search?: string, options?: any) {
        return RequirementV1ApiFp(this.configuration).search2(courseId, semesterId, challengeId, search, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update existing requirement based on id.
     * @param {RequirementRequestDtoV1} body 
     * @param {number} courseId 
     * @param {number} semesterId 
     * @param {number} challengeId 
     * @param {number} requirementId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RequirementV1Api
     */
    public update1(body: RequirementRequestDtoV1, courseId: number, semesterId: number, challengeId: number, requirementId: number, options?: any) {
        return RequirementV1ApiFp(this.configuration).update1(body, courseId, semesterId, challengeId, requirementId, options)(this.fetch, this.basePath);
    }

}
